// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: rooms.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createPublicRoom = `-- name: CreatePublicRoom :exec
insert into rooms(name, description, room_type) 
values ($1, $2, $3)
`

type CreatePublicRoomParams struct {
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
	RoomType    string      `json:"room_type"`
}

func (q *Queries) CreatePublicRoom(ctx context.Context, arg CreatePublicRoomParams) error {
	_, err := q.db.Exec(ctx, createPublicRoom, arg.Name, arg.Description, arg.RoomType)
	return err
}

const getPrivateRooms = `-- name: GetPrivateRooms :many
select
    usr.first_name || ' ' || usr.last_name as full_name,
    usr.status,
    usr.user_id,
    usr.updated_at,
    shared_cr.room_id
from
    chat_rooms as specific_user_cr
join
    rooms as r on specific_user_cr.room_id = r.room_id
join
    chat_rooms as shared_cr on r.room_id = shared_cr.room_id
join
    users as usr on shared_cr.user_id = usr.user_id
where
    specific_user_cr.user_id = $1
    and r.room_type = 'private'
    and usr.user_id <> $1
order by
    usr.updated_at desc
`

type GetPrivateRoomsRow struct {
	FullName  interface{}        `json:"full_name"`
	Status    string             `json:"status"`
	UserID    uuid.UUID          `json:"user_id"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	RoomID    uuid.UUID          `json:"room_id"`
}

func (q *Queries) GetPrivateRooms(ctx context.Context, userID uuid.UUID) ([]GetPrivateRoomsRow, error) {
	rows, err := q.db.Query(ctx, getPrivateRooms, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPrivateRoomsRow{}
	for rows.Next() {
		var i GetPrivateRoomsRow
		if err := rows.Scan(
			&i.FullName,
			&i.Status,
			&i.UserID,
			&i.UpdatedAt,
			&i.RoomID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRoomDetails = `-- name: GetRoomDetails :one
select name, room_type from rooms
where room_id = $1
`

type GetRoomDetailsRow struct {
	Name     string `json:"name"`
	RoomType string `json:"room_type"`
}

func (q *Queries) GetRoomDetails(ctx context.Context, roomID uuid.UUID) (GetRoomDetailsRow, error) {
	row := q.db.QueryRow(ctx, getRoomDetails, roomID)
	var i GetRoomDetailsRow
	err := row.Scan(&i.Name, &i.RoomType)
	return i, err
}

const getUsersInRoom = `-- name: GetUsersInRoom :many
select 
    users.first_name || ' ' || users.last_name as full_name,
    users.status,
    users.user_id,
    users.updated_at,
    rooms.name
from users
join chat_rooms using(user_id)
join rooms using (room_id)
where rooms.room_id = $1
order by users.updated_at desc
limit $2
`

type GetUsersInRoomParams struct {
	RoomID uuid.UUID `json:"room_id"`
	Limit  int32     `json:"limit"`
}

type GetUsersInRoomRow struct {
	FullName  interface{}        `json:"full_name"`
	Status    string             `json:"status"`
	UserID    uuid.UUID          `json:"user_id"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	Name      string             `json:"name"`
}

func (q *Queries) GetUsersInRoom(ctx context.Context, arg GetUsersInRoomParams) ([]GetUsersInRoomRow, error) {
	rows, err := q.db.Query(ctx, getUsersInRoom, arg.RoomID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUsersInRoomRow{}
	for rows.Next() {
		var i GetUsersInRoomRow
		if err := rows.Scan(
			&i.FullName,
			&i.Status,
			&i.UserID,
			&i.UpdatedAt,
			&i.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initiatePrivateRoom = `-- name: InitiatePrivateRoom :one
select create_private_room from create_private_room($1, $2)
`

type InitiatePrivateRoomParams struct {
	UserA uuid.UUID `json:"user_a"`
	UserB uuid.UUID `json:"user_b"`
}

func (q *Queries) InitiatePrivateRoom(ctx context.Context, arg InitiatePrivateRoomParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, initiatePrivateRoom, arg.UserA, arg.UserB)
	var create_private_room pgtype.UUID
	err := row.Scan(&create_private_room)
	return create_private_room, err
}

const joinRoom = `-- name: JoinRoom :exec
insert into chat_rooms(user_id, room_id) 
values ($1, $2)
on conflict (user_id, room_id) do nothing
`

type JoinRoomParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) JoinRoom(ctx context.Context, arg JoinRoomParams) error {
	_, err := q.db.Exec(ctx, joinRoom, arg.UserID, arg.RoomID)
	return err
}

const leaveRoom = `-- name: LeaveRoom :exec
delete from chat_rooms 
where user_id = $1
and room_id =  $2
`

type LeaveRoomParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoomID uuid.UUID `json:"room_id"`
}

func (q *Queries) LeaveRoom(ctx context.Context, arg LeaveRoomParams) error {
	_, err := q.db.Exec(ctx, leaveRoom, arg.UserID, arg.RoomID)
	return err
}

const listPublicRooms = `-- name: ListPublicRooms :many
select room_id, name, description from rooms where room_type = 'public'
`

type ListPublicRoomsRow struct {
	RoomID      uuid.UUID   `json:"room_id"`
	Name        string      `json:"name"`
	Description pgtype.Text `json:"description"`
}

func (q *Queries) ListPublicRooms(ctx context.Context) ([]ListPublicRoomsRow, error) {
	rows, err := q.db.Query(ctx, listPublicRooms)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListPublicRoomsRow{}
	for rows.Next() {
		var i ListPublicRoomsRow
		if err := rows.Scan(&i.RoomID, &i.Name, &i.Description); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
